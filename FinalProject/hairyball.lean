import Mathlib

noncomputable section

open RealInnerProductSpace
open Polynomial MeasureTheory Metric ENNReal Topology Set Filter Function

notation "E" n:30 => EuclideanSpace ‚Ñù (Fin n)
notation "S" n:30 "_(" r:10 ")" => Metric.sphere (0 : EuclideanSpace ‚Ñù (Fin n)) r


structure IsSphVF {n : ‚Ñï} (v : EuclideanSpace ‚Ñù (Fin n) ‚Üí EuclideanSpace ‚Ñù (Fin n)) where
  diff : ContDiff ‚Ñù ‚ä§ v
  perp : ‚àÄx, ‚Äñx‚Äñ = 1 ‚Üí ‚ü™x, v x‚ü´ = 0

structure IsEqvSphVF {n : ‚Ñï}
  (v : EuclideanSpace ‚Ñù (Fin n) ‚Üí EuclideanSpace ‚Ñù (Fin n)) extends IsSphVF v where
  equiv : ‚àÄ r > (0 : ‚Ñù), ‚àÄ x, v (r ‚Ä¢ x) = r ‚Ä¢ v x



def suff_small_inj {n} (f: ‚Ñù ‚Üí E n ‚Üí E n) := ‚àÄ·∂† t in ùìù (0:‚Ñù), Injective (f t)
def suff_small_surj {n} (f: ‚Ñù ‚Üí E n ‚Üí E n) := ‚àÄ·∂† t in ùìù (0:‚Ñù), Surjective (f t)
def IsPolynomialFun (f : ‚Ñù ‚Üí ‚Ñù) := ‚àÉ P : ‚Ñù[X], f = P.eval

example (P Q : ‚Ñù[X]) (h : P.eval = Q.eval) : P = Q := Polynomial.funext (congrFun h)

-- some examples of using ‚àÄ·∂†, thanks Prof. Massot!
example {K : ‚Ñù} (hK : K > 0) : ‚àÄ·∂† t in ùìù (0 : ‚Ñù), K*|t| < 1 := by
  have F‚ÇÅ : ‚àÄ t ‚àà Ioo (-(1/K)) (1/K), K*|t| < 1 := by
    intro t ht
    have : |t| < 1/K := abs_lt.mpr ht
    rwa [lt_div_iff' hK] at this
  have F‚ÇÇ : ‚àÄ·∂† t in ùìù (0 : ‚Ñù), t ‚àà Ioo (-(1/K)) (1/K) := by
    refine Ioo_mem_nhds ?ha ?hb <;> simp [hK]
  exact  F‚ÇÇ.mono F‚ÇÅ


example {K : ‚Ñù} : ‚àÄ·∂† t in ùìù (0 : ‚Ñù), K*|t| < 1 := by
  have F‚ÇÅ : Tendsto (fun t ‚Ü¶ K*|t|) (ùìù 0) (ùìù 0) := by
    suffices Tendsto (fun t ‚Ü¶ K*|t|) (ùìù 0) (ùìù (K*0)) by simpa
    refine Tendsto.const_mul K ?h
    suffices Tendsto (fun t : ‚Ñù ‚Ü¶ |t|) (ùìù 0) (ùìù (|0|)) by simpa
    exact continuous_abs.continuousAt
  have F‚ÇÇ : Iio (1 : ‚Ñù) ‚àà ùìù 0 := Iio_mem_nhds zero_lt_one
  exact F‚ÇÅ.eventually F‚ÇÇ


lemma smooth_imp_c1 {n} (v : E n ‚Üí E n) (hv : ContDiff ‚Ñù ‚ä§ v) : ContDiff ‚Ñù 1 v :=
  hv.of_le le_top

lemma c1_implies_lipschitz {n} (v : E n ‚Üí E n) (hv : ContDiff ‚Ñù ‚ä§ v) : ‚àÉ K > 0, LipschitzWith K v := by sorry

lemma c1_implies_lipschitz2 {n} (v : E n ‚Üí E n) (hv : ContDiff ‚Ñù ‚ä§ v) (A : Set (E n)) (hA : Convex ‚Ñù A) : ‚àÉ K : NNReal, LipschitzWith K (Set.restrict A v) := by
  sorry

lemma sqrt_poly {n} (h : IsPolynomialFun (fun x ‚Ü¶ (1+x^2)^(n/2))) : Even n := by

  let q : ‚Ñù ‚Üí ‚Ñù := fun x ‚Ü¶ (1 + x^2)^(n/2 : ‚Ñù)
  have hq : IsPolynomialFun (q*q) := by
    use (1+X^2)^n
    ext z
    simp
    rw [‚Üê Real.rpow_add, ‚Üê Real.rpow_nat_cast]
    field_simp
    positivity
  rcases hq with ‚ü®k, hk‚ü©
  sorry

-- lemma poly_transform {n} (v : E n ‚Üí E n) (hv : ContDiff ‚Ñù ‚ä§ v) (A : Set (E n)) (hA : IsCompact A) :
--   ‚àÄ·∂† t in ùìù 0, (Function.Injective (fun x : A ‚Ü¶ x + t ‚Ä¢ (v x)) ‚àß
--   IsPolynomialFun (fun t ‚Ü¶ volume ((fun x : A ‚Ü¶ x + t ‚Ä¢ (v x))'' A))) := sorry

theorem hairy_ball_aux {n} {v : E n ‚Üí E n} (h : IsEqvSphVF v) (h' : ‚àÄx, ‚Äñx‚Äñ = 1 ‚Üí v x ‚â† 0) : Even n := sorry


lemma norm_sub_norm_le'' {F : Type*} [SeminormedAddGroup F] (a b : F) : ‚Äña‚Äñ - ‚Äñb‚Äñ ‚â§ ‚Äña + b‚Äñ := by
  convert norm_sub_norm_le a (-b) using 1 <;> simp

def f {n} (v : E n ‚Üí E n) (t : ‚Ñù) (x : E n) : E n := x + t ‚Ä¢ (v x)

def H {n} (t : ‚Ñù) (x : E n) : E n := t ‚Ä¢ x

lemma f_inj {n} {v : E n ‚Üí E n} (h : IsSphVF v) : suff_small_inj (f v) := by
  rcases (c1_implies_lipschitz v h.diff) with ‚ü®K, hK‚ü©
  have hK‚ÇÅ := hK.1
  have hK‚ÇÇ := hK.2
  have F‚ÇÅ : ‚àÄ·∂† t in ùìù (0 : ‚Ñù), ‚àÉC > 0, AntilipschitzWith (C : NNReal) (f v t) := by
    have G‚ÇÅ : ‚àÄ t, ‚àÄ x y : E n, ‚Äñf v t x - f v t y‚Äñ ‚â• (1-(K:‚Ñù)*|t|) * ‚Äñx-y‚Äñ := by
      intro t x y
      calc
        ‚Äñf v t x - f v t y‚Äñ = ‚Äñx - y + t ‚Ä¢ (v x - v y)‚Äñ := by congr 1; rw [smul_sub]; dsimp [f]; abel
        _ ‚â• ‚Äñx-y‚Äñ - ‚Äñt ‚Ä¢ (v x - v y)‚Äñ := by apply norm_sub_norm_le''
        _ = ‚Äñx-y‚Äñ - |t| * ‚Äñv x - v y‚Äñ := by rw [norm_smul, Real.norm_eq_abs]
        _ ‚â• ‚Äñx-y‚Äñ - |t| * (K * ‚Äñx-y‚Äñ) := by gcongr ; apply hK‚ÇÇ.dist_le_mul
        _ = (1-K*|t|)*‚Äñx-y‚Äñ := by linarith

    have G‚ÇÇ : ‚àÄ·∂† t in ùìù (0 : ‚Ñù), (K:‚Ñù)*|t| < 1 := by
      have H‚ÇÅ : ‚àÄ t ‚àà Ioo (-(1/(K:‚Ñù))) (1/(K:‚Ñù)), K*|t| < 1 := by
        intro t ht
        have : |t| < 1/K := abs_lt.mpr ht
        have hK‚ÇÅ' : (0 : ‚Ñù) < K := by exact_mod_cast hK‚ÇÅ
        rwa [lt_div_iff' hK‚ÇÅ'] at this
      have H‚ÇÇ : ‚àÄ·∂† t in ùìù (0 : ‚Ñù), t ‚àà Ioo (-(1/(K:‚Ñù))) (1/(K:‚Ñù)) := by
        refine Ioo_mem_nhds ?ha ?hb <;> simp [hK]
      exact H‚ÇÇ.mono H‚ÇÅ

    have G‚ÇÉ : ‚àÄ (t : ‚Ñù), (K:‚Ñù) * |t| < 1 ‚Üí 1 - (K:‚Ñù) * |t| > 0 := by
      intro t ht
      linarith

    have G‚ÇÑ := G‚ÇÇ.mono G‚ÇÉ

    have G‚ÇÖ : ‚àÄ (t : ‚Ñù), 1-(K:‚Ñù) * |t| > 0 ‚Üí ‚àÉ C > 0, AntilipschitzWith C (f v t) := by
      intro t ht
      use 1/‚ü®1-K*|t|, ht.le‚ü©
      constructor
      ¬∑ exact one_div_pos.mpr ht
      ¬∑ rw [antilipschitzWith_iff_le_mul_dist]
        peel G‚ÇÅ t with H y x
        field_simp
        exact (le_div_iff' ht).mpr (G‚ÇÅ t y x)

    exact G‚ÇÑ.mono G‚ÇÖ

  have F‚ÇÇ : ‚àÄ t, (‚àÉ C > 0, AntilipschitzWith C (f v t)) ‚Üí Injective (f v t) := by
    intro t hc
    rcases hc with ‚ü®c,_,hcc‚ü©
    apply AntilipschitzWith.injective
    exact hcc

  exact F‚ÇÅ.mono F‚ÇÇ

lemma f_surj {n} {v : E n ‚Üí E n} (h : IsSphVF v) (hv : ‚àÄ u : E n, ‚Äñu‚Äñ = 1 ‚Üí ‚Äñv u‚Äñ = 1): ‚àÄ·∂† t in ùìù (0 : ‚Ñù), (‚àÄ u : E n, ‚Äñu‚Äñ = 1 ‚Üí ‚Äñf v t u‚Äñ = Real.sqrt (1 + t^2))
  ‚àß (‚àÄ u' : E n, ‚Äñu'‚Äñ = Real.sqrt (1 + t^2) ‚Üí ‚àÉ u : E n, ‚Äñu‚Äñ = 1 ‚àß f v t u = u') := by
  have fact : ‚àÄ t : ‚Ñù, ‚àÄ u : E n, ‚Äñu‚Äñ = 1 ‚Üí ‚Äñf v t u‚Äñ = Real.sqrt (1 + t^2) := by
    intro t u hu
    have square : ‚Äñf v t u‚Äñ^2 = 1 + t^2 := by
      calc ‚Äñf v t u‚Äñ^2 = ‚Äñu + t ‚Ä¢ v u‚Äñ^2 := by congr
        _ = ‚Äñu‚Äñ^2 + 2 * ‚ü™u, (t ‚Ä¢ v u)‚ü´ + ‚Äñt ‚Ä¢ v u‚Äñ^2 := norm_add_sq_real u (t ‚Ä¢ v u)
        _ = ‚Äñu‚Äñ^2  + ‚Äñt ‚Ä¢ v u‚Äñ^2 := by
          simp [-PiLp.inner_apply, real_inner_smul_right, h.perp _ hu]
        _ = 1 + ‚Äñt ‚Ä¢ v u‚Äñ^2 := by
          rw [hu]
          simp
        _ = 1 + t^2 * ‚Äñv u‚Äñ^2 := by
          rw [norm_smul, mul_pow]
          simp
        _ = 1 + t^2 := by
          rw [hv u hu]
          simp
    have pos1 : 0 ‚â§ ‚Äñf v t u‚Äñ := by exact norm_nonneg (f v t u)
    have pos2 : 0 ‚â§ 1 + t^2 := by
      calc 0 ‚â§ t^2 := sq_nonneg t
        _ ‚â§ 1 + t^2 := by linarith
    apply Eq.symm
    rw [Real.sqrt_eq_iff_sq_eq pos2 pos1]
    exact square
  let g := fun v t x ‚Ü¶ (1 / (Real.sqrt (1 + t^2))) ‚Ä¢ (f (n := n) v t x)
  let g‚ÇÄ := fun v t ‚Ü¶ Set.restrict {x : E n | ‚Äñx‚Äñ = 1} (g v t)
  have hg‚ÇÄ : ‚àÄ t : ‚Ñù, ‚àÄ x : {x : E n | ‚Äñx‚Äñ = 1}, g‚ÇÄ v t x ‚àà {x : E n | ‚Äñx‚Äñ = 1} := by sorry
  let g‚ÇÅ := fun t ‚Ü¶ Set.codRestrict (g‚ÇÄ v t) {x : E n | ‚Äñx‚Äñ = 1} (hg‚ÇÄ t)

  let h := fun (y : {x : E n | ‚Äñx‚Äñ = 1}) t (x : {x : E n | ‚Äñx‚Äñ = 1}) ‚Ü¶ Real.sqrt (1 + t^2) ‚Ä¢ y - t ‚Ä¢ v x
  have fxd_pt : ‚àÄ·∂† t in ùìù (0 : ‚Ñù), ‚àÄ y : {x : E n | ‚Äñx‚Äñ = 1}, ‚àÉ x : {x : E n | ‚Äñx‚Äñ = 1}, Function.IsFixedPt (h y t) x
  sorry

lemma annulem {n} : {x : E n | 0.5 ‚â§ ‚Äñx‚Äñ ‚àß ‚Äñx‚Äñ ‚â§ 1.5} = ‚ãÉ (r ‚àà Icc (0.5: ‚Ñù) (1.5: ‚Ñù)), {x : E n | ‚Äñx‚Äñ = r}  := by
  ext y
  constructor
  ¬∑ intro hy
    dsimp at *
    rw [mem_iUnion]
    simp [hy]
  ¬∑ intro hy
    rw [mem_iUnion] at hy
    rcases hy with ‚ü®s, hy‚ü©
    rw [mem_iUnion] at hy
    rcases hy with ‚ü®w, hw‚ü©
    rw [mem_setOf_eq, hw]
    exact w

lemma f_surj_new {n} {v : E n ‚Üí E n} (h : IsSphVF v) (hv : ‚àÄ x : E n, ‚Äñv x‚Äñ = ‚Äñx‚Äñ ‚àß ‚ü™x, v x‚ü´ = 0) (hv' : ‚àÄ r : ‚Ñù, ‚àÄ x : E n, v (r ‚Ä¢ x) = r ‚Ä¢ v x) : ‚àÄ·∂† t in ùìù (0 : ‚Ñù), (‚àÄ u : E n, ‚Äñu‚Äñ = 1 ‚Üí ‚Äñf v t u‚Äñ = Real.sqrt (1 + t^2))
  ‚àß (‚àÄ u' : E n, ‚Äñu'‚Äñ = Real.sqrt (1 + t^2) ‚Üí ‚àÉ u : E n, ‚Äñu‚Äñ = 1 ‚àß f v t u = u') := by
  have norm_lemma : ‚àÄ t : ‚Ñù, ‚àÄ x : E n, ‚Äñx + t ‚Ä¢ v x‚Äñ = ‚Äñx‚Äñ * Real.sqrt (1 + t^2) := by
    intro t x
    have square : ‚Äñx + t ‚Ä¢ v x‚Äñ^2 = ‚Äñx‚Äñ^2 * (1 + t^2) := by
      calc ‚Äñx + t ‚Ä¢ v x‚Äñ^2 = ‚Äñx‚Äñ^2 + 2 * ‚ü™x, (t ‚Ä¢ v x)‚ü´ + ‚Äñt ‚Ä¢ v x‚Äñ^2 := norm_add_sq_real x (t ‚Ä¢ v x)
        _ = ‚Äñx‚Äñ^2 + ‚Äñt ‚Ä¢ v x‚Äñ^2 := by
          simp [-PiLp.inner_apply, real_inner_smul_right, (hv x).right]
        _ = ‚Äñx‚Äñ^2 + t^2 * ‚Äñv x‚Äñ^2 := by
          rw [norm_smul, mul_pow]
          simp
        _ = ‚Äñx‚Äñ^2 * (1 + t^2) := by
          rw [mul_comm, (hv x).left]
          exact (mul_one_add (‚Äñx‚Äñ ^ 2) (t ^ 2)).symm
    have pos1 : 0 ‚â§ ‚Äñx + t ‚Ä¢ v x‚Äñ := by exact norm_nonneg (x + t ‚Ä¢ v x)
    have pos2 : 0 ‚â§ ‚Äñx‚Äñ^2 * (1 + t^2) := by
      have pos3 : 0 ‚â§ 1 + t^2 := calc 0 ‚â§ t^2 := sq_nonneg t
          _ ‚â§ 1 + t^2 := by linarith
      exact mul_nonneg (sq_nonneg ‚Äñx‚Äñ) pos3
    calc ‚Äñx + t ‚Ä¢ v x‚Äñ = Real.sqrt (‚Äñx‚Äñ^2 * (1 + t^2)) := ((fun {x y} hx hy ‚Ü¶ (Real.sqrt_eq_iff_sq_eq hx hy).mpr) pos2 pos1 square).symm
      _ = Real.sqrt (‚Äñx‚Äñ^2) * Real.sqrt (1 + t^2) := by
        refine Real.sqrt_mul (sq_nonneg ‚Äñx‚Äñ) (1 + t ^ 2)
      _ = ‚Äñx‚Äñ * Real.sqrt (1 + t^2) := by
        congr
        refine Real.sqrt_sq (norm_nonneg x)
  have first : ‚àÄ·∂† t in ùìù (0 : ‚Ñù), ‚àÄ u : E n, ‚Äñu‚Äñ = 1 ‚Üí ‚Äñf v t u‚Äñ = Real.sqrt (1 + t^2) := by
    have fact : ‚àÄ t : ‚Ñù, ‚àÄ u : E n, ‚Äñu‚Äñ = 1 ‚Üí ‚Äñf v t u‚Äñ = Real.sqrt (1 + t^2) := by
      intro t u hu
      unfold f
      rw [norm_lemma t u]
      simp [hu]
    sorry
  have second : ‚àÄ·∂† t in ùìù (0 : ‚Ñù), ‚àÄ u' : E n, ‚Äñu'‚Äñ = Real.sqrt (1 + t^2) ‚Üí ‚àÉ u : E n, ‚Äñu‚Äñ = 1 ‚àß f v t u = u' := by
    have LipCst : ‚àÉ K > 0, LipschitzWith K (Set.restrict {x : E n | 1/2 ‚â§ ‚Äñx‚Äñ ‚àß ‚Äñx‚Äñ ‚â§ 3/2} v) := by sorry
    rcases LipCst with ‚ü®K, hvK‚ü©
    have point : ‚àÄ t : ‚Ñù, |t| < 1/3 ‚àß |t| < 1/K ‚Üí ‚àÄ u' : E n, ‚Äñu'‚Äñ = Real.sqrt (1 + t^2) ‚Üí ‚àÉ u : E n, ‚Äñu‚Äñ = 1 ‚àß f v t u = u' := by
      intro t ht u' hu'
      have hu'' : ‚Äñu'‚Äñ = |Real.sqrt (1 + t^2)| := by
        rw [hu']
        exact (LatticeOrderedGroup.abs_of_nonneg (Real.sqrt (1 + t^2)) (Real.sqrt_nonneg (1 + t ^ 2))).symm
      have calculation : |1/(Real.sqrt (1 + t^2))| * |Real.sqrt (1 + t^2)| = 1 := by
        rw [abs_one_div (Real.sqrt (1 + t^2))]
        dsimp -- lmao no way i'm stuck on this
        sorry
      unfold f
      let A := {x : E n | 1/2 ‚â§ ‚Äñx‚Äñ ‚àß ‚Äñx‚Äñ ‚â§ 3/2}
      let g := fun x : {x : E n | 1/2 ‚â§ ‚Äñx‚Äñ ‚àß ‚Äñx‚Äñ ‚â§ 3/2} ‚Ü¶ (1/(Real.sqrt (1 + t^2))) ‚Ä¢ u' - t ‚Ä¢ v x
      have restr : ‚àÄ x : {x : E n | 1/2 ‚â§ ‚Äñx‚Äñ ‚àß ‚Äñx‚Äñ ‚â§ 3/2}, g x ‚àà {x : E n | 1/2 ‚â§ ‚Äñx‚Äñ ‚àß ‚Äñx‚Äñ ‚â§ 3/2} := by
        intro x
        have : |t| * ‚Äñ(x : E n)‚Äñ ‚â§ 1/2 := by
          calc |t| * ‚Äñ(x : E n)‚Äñ ‚â§ 1/3 * 3/2 := by sorry
            _ = 1/2 := by ring
        have : 1 - 1/2 ‚â§ 1 - |t| * ‚Äñ(x : E n)‚Äñ := by
          sorry
        constructor
        ¬∑ dsimp
          calc 1/2 = 1 - 1/2 := by ring
            _ ‚â§ |1/(Real.sqrt (1 + t^2))| * ‚Äñu'‚Äñ - |t| * ‚Äñ(x : E n)‚Äñ := by
              rw [hu'', calculation]
              exact this
            _ = ‚Äñ(1/(Real.sqrt (1 + t^2))) ‚Ä¢ u'‚Äñ - ‚Äñt ‚Ä¢ v x‚Äñ := by
              congr
              sorry
            _ ‚â§ |‚Äñ(1/(Real.sqrt (1 + t^2))) ‚Ä¢ u'‚Äñ - ‚Äñt ‚Ä¢ v x‚Äñ| := le_abs_self (‚Äñ(1 / Real.sqrt (1 + t ^ 2)) ‚Ä¢ u'‚Äñ - ‚Äñt ‚Ä¢ v ‚Üëx‚Äñ)
            _ ‚â§ ‚Äñ(1/(Real.sqrt (1 + t^2))) ‚Ä¢ u' - t ‚Ä¢ v x‚Äñ := by apply abs_norm_sub_norm_le
        ¬∑ dsimp
          calc ‚Äñ(1 / Real.sqrt (1 + t ^ 2)) ‚Ä¢ u' - t ‚Ä¢ v ‚Üëx‚Äñ ‚â§ ‚Äñ(1 / Real.sqrt (1 + t ^ 2)) ‚Ä¢ u'‚Äñ + ‚Äñt ‚Ä¢ v ‚Üëx‚Äñ := by sorry
            _ ‚â§ 1 + t * ‚Äñ(x : E n)‚Äñ := by sorry
            _ ‚â§ 3/2 := by sorry
      let h := fun z ‚Ü¶ (Set.codRestrict g {x : E n | 1/2 ‚â§ ‚Äñx‚Äñ ‚àß ‚Äñx‚Äñ ‚â§ 3/2} restr z)
      have complete : IsComplete {x : E n | 1/2 ‚â§ ‚Äñx‚Äñ ‚àß ‚Äñx‚Äñ ‚â§ 3/2} := by
        sorry
      have key : ‚àÉ u, Function.IsFixedPt h u := by sorry
      rcases key with ‚ü®u, hu‚ü©
      use u
      have key' : u + t ‚Ä¢ v u = u' := by sorry
      constructor
      ¬∑ have fact‚ÇÄ : 1 + t^2 = ‚Äñ(u : E n)‚Äñ^2 * (1 + t^2) := by sorry
        have fact‚ÇÅ : 1 = ‚Äñ(u : E n)‚Äñ := by sorry
        rw [fact‚ÇÅ]
      ¬∑ exact key'
    sorry

  exact first.and second



theorem hairy_ball {n} {v : E n ‚Üí E n} (h : IsSphVF v) (h' : ‚àÄx, ‚Äñx‚Äñ = 1 ‚Üí v x ‚â† 0) (h'' :
‚àÄ x, ‚Äñx‚Äñ = 1 ‚Üí ‚Äñv x‚Äñ = 1) : Even n := by
  have ss_inj : suff_small_inj (f v) := f_inj h
  have ss_surj := f_surj h h''
  sorry



#check volume (ball (0 : E 3) 1)
